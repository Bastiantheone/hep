package job

import (
	"fmt"
	"io"
	"os"
	"reflect"
	"strings"
)

// NewGoEncoder returns a new encoder that writes to w
func NewGoEncoder(w io.Writer) *GoEncoder {
	if w == nil {
		w = os.Stdout
	}
	return &GoEncoder{
		w: w,
	}
}

// A GoEncoder writes a go representation to an output stream
type GoEncoder struct {
	w    io.Writer
	init bool
}

// Encode encodes data into the underlying io.Writer
func (enc *GoEncoder) Encode(data interface{}) error {
	var err error
	stmts, ok := data.([]Stmt)
	if !ok {
		return fmt.Errorf("fwk/job: expected a []job.Stmt as input. got %T", data)
	}

	if !enc.init {
		fmt.Fprintf(enc.w, `// automatically generated by github.com/go-hep/fwk/job.
// do NOT edit!

package main

`,
		)

		dpkgs := make(map[string]struct{}) // dash-import packages
		ipkgs := make(map[string]struct{}) // import packages
		for _, stmt := range stmts {
			switch stmt.Type {
			case StmtNewApp, StmtCreate:
				typename := stmt.Data.Type
				i := strings.LastIndex(typename, ".")
				if i == -1 {
					return fmt.Errorf("fwk/job: invalid package name %q (no dot)", typename)
				}
				//typ := typename[i+1:]
				pkg := typename[:i]
				dpkgs[pkg] = struct{}{}
			}

			for _, v := range stmt.Data.Props {
				typ := reflect.TypeOf(v)
				pkg := typ.PkgPath()
				if pkg == "" {
					continue
				}
				ipkgs[pkg] = struct{}{}
			}
		}

		fmt.Fprintf(enc.w, "import (\n")
		fmt.Fprintf(enc.w, "\t%q\n\n", "github.com/go-hep/fwk/job")

		for pkg := range ipkgs {
			fmt.Fprintf(enc.w, "\t%q\n", pkg)
		}

		for pkg := range dpkgs {
			_, dup := ipkgs[pkg]
			if dup {
				// already imported.
				continue
			}
			fmt.Fprintf(enc.w, "\t_ %q\n", pkg)
		}
		fmt.Fprintf(enc.w, ")\n")
	}

	for _, stmt := range stmts {
		fmt.Printf(">>> %#v\n", stmt)
	}

	return err
}
